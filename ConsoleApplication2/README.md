
# Информация на тему списков

Односвязный список – это структура данных, которая представляет собой последовательность элементов, связанных друг с другом указателями. Каждый элемент списка содержит данные и указатель на следующий элемент. Это позволяет эффективно добавлять и удалять элементы из списка, обеспечивает простой доступ к элементам, а также позволяет реализовать различные операции над данными, такие как поиск, вставка, удаление и т. д. Односвязные списки широко используются в программировании и имеют различные вариации, такие как циклические списки и двусвязные списки.

Односвязные списки обладают рядом преимуществ и недостатков. Среди преимуществ можно выделить простоту реализации, эффективность операций добавления и удаления элементов в начале списка, а также эффективность использования памяти (по сравнению с массивами, где необходимо заранее выделить память под определенное количество элементов). Однако недостатком односвязных списков является необходимость последовательного прохода по всем элементам для доступа к конкретному элементу, что делает операции поиска более затратными по времени.

## Описание работы программы

Программа начинается с определения структуры `tovar`, которая содержит информацию о товаре: название (`name`), цену (`price`), количество (`amount`) и указатель на следующий элемент списка (`next`).

```
c++
struct tovar
{
 string name;
 float price;
 int amount;
 tovar* next;
};

```

Затем идут функции для работы с односвязным списком:

▌addfirst - добавление элемента в начало списка

На данном этапе нам не нужна проверка "пустой ли список?". Даже если он оказался пустым, мы с легкостью добавляем в него нужные элементы и раздвигаем границы списка.


```
c++
void addfirst(tovar*& tlist, string n, float p, int am) {
 tovar× newtovar = new tovar;
 newtovar->name = n;
 newtovar->amount = am;
 newtovar->price = p;
 newtovar->next = tlist;
 tlist = newtovar;
}

```

▌addbefove - добавление элемента перед указанным элементом в списке

Мы ставим эту функцию за “int”, так как тут уже нужна проверка пустоты списка. После того, как мы убедились, что наш список не пустой, приступаем к поиску нужного элемента по имени, чтобы поставить перед ним новый элемент пользователя. Далее следует проверка следующего значения после нового элемента. И последняя проверка на то, что если следующий элемент после нового NULL и имя нового элемента, это не имя элемента впереди списка. Если эта проверка оказалась true, то мы добавляем новый элемент перед старым.


```

c++
int addbefove(tovar*& tlist, string n, float p, int am, string nabefove) {
 if (tlist == NULL) return 1;
 if (tlist->name == n)
 {
  addfirst(tlist, n, p, am);
  return 0;
 }
 if (tlist->next == NULL) return 1;
 tovar× newt = tlist, ×tmp = tlist->next;
 while (tmp->next != NULL && tmp->name != nabefove)
 {
  newt = newt->next;
  tmp = tmp->next;
 }
 if (tmp->next == NULL && tmp->name != nabefove) return 1;
 tovar× newtovar = new tovar;
 newtovar->name = n;
 newtovar->price = p;
 newtovar->amount = am;
 newtovar->next = tmp;
 newt->next = newtovar;
 return 0;
}

```

▌addafter - добавление элемента после указанного элемента в списке

Тут так же, как и в предыдущей функции ставим за “int”, так как и здесь нам понадобится проверка на ошибки. В данной функции нам понадобятся две проверки. Первая проверяет, есть ли в нашем списке элементы, если нет, выдает ошибку. Далее мы проверяем, что ссылка на элемент не пустая и она не равна предыдущему, в этом случае мы двигаемся вперед. Если все же ссылка оказывается пустой, выводится ошибка. Во всех остальных случаях мы заполняем список новым элементом.


```
c++
int addafter(tovar*& bufet, string n, float p, int am, string nafter) {
 if (bufet == NULL) return 1;
 tovar× tmp = bufet;
 while (tmp != NULL && tmp->name != nafter) {
  tmp = tmp->next;
 }
 if (tmp == NULL) return 1;
 tovar× newtovar = new tovar;
 newtovar->name = n;
 newtovar->price = p;
 newtovar->amount = am;
 newtovar->next = tmp->next;
 tmp->next= newtovar;
 return 0;
}

```

### `addend` - добавление элемента в конец списка.

Функция `addend` добавляет новый элемент в конец односвязного списка `tovar`.

1.  **Проверка на пустой список:** Сначала проверяется, является ли список `bufet` пустым (равен `NULL`).
2.  **Добавление в пустой список:** Если список пуст, вызывается функция `addfirst`, которая добавляет элемент в начало списка.
3.  **Поиск последнего элемента:** Если список не пуст, функция проходит по списку, пока не достигнет последнего элемента (элемента, у которого `next` равен `NULL`).
4.  **Создание нового элемента:** После нахождения последнего элемента создается новый элемент `newtovar` типа `tovar`, которому присваиваются переданные значения (`n`, `p`, `am`) и `next` устанавливается в `NULL`.
5.  **Привязка нового элемента:** Поле `next` последнего элемента списка устанавливается на `newtovar`, тем самым новый элемент добавляется в конец списка.

```

cpp
void addend(tovar*& bufet, string n, float p, int am)
{
 tovar× tmp = bufet;
 if (bufet == NULL) {
  addfirst(bufet, n, p, am);
  return;
 }
 while (tmp->next) tmp = tmp->next;
 tovar× newtovar = new tovar;
 newtovar->name = n;
 newtovar->price = p;
 newtovar->amount = am;
 newtovar->next = NULL;
 tmp->next = newtovar;
}

```

▌printlist - печать содержимого списка.

Функция printlist выводит на экран содержимое списка tovar.

1. Проверка на пустой список: Проверяется, является ли список пустым. Если список пуст, то выводить нечего.
2. Обход списка: Если список не пуст, функция проходит по списку, пока не достигнет конца списка.
3. Вывод данных: Для каждого элемента списка выводится на экран его имя (name), цена (price) и количество (amount).


```

cpp
void printlist(tovar* bufet) {
  while (bufet != NULL) {
    cout << "Name:" << bufet->name << " Price:" << bufet->price << " Amount:" << bufet->amount << "\n";
    bufet = bufet->next;
  }
}

```

▌DelNode - удаление элемента из списка.

Функция DelNode удаляет из списка tovar элемент с заданным именем DelName.

1. Проверка на пустой список: Проверяется, является ли список пустым. Если список пуст, функция возвращает 1, сообщая об ошибке.
2. Удаление первого элемента: Если первый элемент списка имеет имя DelName, то указатель bufet смещается на следующий элемент, первый элемент удаляется, и функция возвращает 0.
3. Проверка на единственный элемент: Если первый элемент не является удаляемым и он единственный в списке, функция возвращает 1, сообщая об ошибке.
4. Поиск удаляемого элемента: Функция проходит по списку, пока не найдет элемент с именем DelName или не достигнет конца списка.
5. Удаление элемента: Если элемент с именем DelName найден, то элемент удаляется из списка путем перенаправления указателя next предыдущего элемента на следующий элемент за удаляемым.
6. Обработка случая не нахождения элемента: Если при обходе списка, элемент с именем DelName не найден, то функция возвращает 1, сообщая об ошибке.


```

cpp
int DelNode(tovar * &bufet, string DelName) {
 if (bufet == NULL) return 1;        
  tovar× tmp = bufet;
  if (bufet->name == DelName) {
    bufet = bufet->next;
    delete tmp;            
    return 0;
  }        
  if (bufet->next == NULL) return 1;
  tovar× prev = bufet;        
  tmp = bufet->next;
  while (tmp->next != NULL && tmp->name != DelName) {
   prev = prev->next;
   tmp = tmp->next;
  }
  if (tmp->next == NULL && tmp->name != DelName) return 1;
  prev->next = tmp->next;        
  delete tmp;
  return 0;
}

```

▌main - главная функция программы.

Функция main демонстрирует использование функций для работы со списком tovar.

1. Инициализация списка: Создается указатель bufet на начало односвязного списка и инициализируется значением NULL.
2. Заполнение списка: Вызываются функции addfirst, addafter, addbefove и addend для добавления элементов в список.
3. Вывод списка: Вызывается функция printlist для вывода содержимого списка на экран.
4. Удаление элементов: Вызывается функция DelNode для удаления всех элементов из списка.
5. Вывод списка после удаления: Вызывается функция printlist еще раз для проверки, что список пуст.


```

cpp
int main()
{
  setlocale(LC_ALL, "rus");
  tovar* bufet = NULL; 
  addfirst(bufet, "Cake1", 20.34f, 10);
  addfirst(bufet, "Cake2", 19.43f, 8);
  addafter(bufet, "Cake3", 54.77f, 3, "Cake2");
  addbefove(bufet, "Cake4", 1.43f, 6, "Cake3");
  addbefove(bufet, "Cake5", 190.43f, 15, "Cake4");
  addend(bufet, "Cake6", 200.43f, 90);
  addbefove(bufet, "Cake7", 50.43f, 45, "Cake6");
  cout << "list:" << endl;
  printlist(bufet);
  DelNode(bufet, "Cake1");
  DelNode(bufet, "Cake2");
  DelNode(bufet, "Cake3");
  DelNode(bufet, "Cake4");
  DelNode(bufet, "Cake5");
  DelNode(bufet, "Cake6");
  DelNode(bufet, "Cake7");
  cout << "\n" << "Список после удаления элементов" << "\n";
  printlist(bufet);
  cout << "\n" << "Как видим список пуст";
  return 0;
}


```

В результате выполнения программы на экран будет выведен список товаров в буфете с их названиями, ценами и количествами, а затем пустой список после удаления всех элементов. Этот код демонстрирует использование структур данных и функций для работы с односвязным списком в языке программирования C++ через использование консольного вывода для отображения результатов операций.


